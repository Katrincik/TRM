<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR Interaction Lab (No Super-Hands)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- AR.js NFT build for image-tracking (iset/fset/fset3) -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar-nft.js"></script>

  <style>
    body { margin:0; overflow:hidden; }
    .hud {
      position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%);
      display: grid; grid-template-columns: repeat(5, auto); gap: 8px;
      font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 10; pointer-events: none;
    }
    .hud.hidden { display: none; }
    .hud button {
      pointer-events: auto;
      padding: 10px 12px; border: 0; border-radius: 10px;
      background: rgba(255,255,255,.9);
    }
    .story {
      position: fixed; top: 14px; left: 50%; transform: translateX(-50%);
      padding: 10px 14px; border-radius: 12px;
      background: rgba(0,0,0,0.55); color: #f7f3e9;
      font: 700 15px/1.2 "Helvetica Neue", Arial, sans-serif;
      letter-spacing: 0.3px; text-shadow: 0 1px 6px rgba(0,0,0,0.6);
      pointer-events: none;

      opacity: 0;
      transition: opacity 0.45s ease;
    }

    .story.visible { opacity: 1; }
  </style>

  <script>
  // ---------- Utilities ----------
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  // Billboard text toward camera
  AFRAME.registerComponent('look-at-camera', {
    tick: function(){
      const cam = this.el.sceneEl && this.el.sceneEl.camera;
      if (!cam) return;
      this.el.object3D.lookAt(cam.position);
    }
  });

  // Render text above everything (disable depth testing)
  AFRAME.registerComponent('always-on-top', {
    schema: {order: {default: 9999}},
    init(){
      const mesh = this.el.getObject3D('mesh');
      if (mesh && mesh.material) {
        mesh.material.depthTest = false;
        mesh.material.depthWrite = false;
      }
      this.el.object3D.renderOrder = this.data.order;
      this.el.addEventListener('object3dset', () => {
        const m = this.el.getObject3D('mesh')?.material;
        if (m) { m.depthTest = false; m.depthWrite = false; }
      });
    }
  });

  // ---------- 1) Tap / doubletap / longpress ----------
  AFRAME.registerComponent('tap-gestures', {
    schema: {longMs:{default:500}},
    init () {
      let lastTap = 0, pressTimer = null, down = false;
      this.el.addEventListener('mousedown', () => {
        down = true;
        const now = performance.now();
        if (now - lastTap < 300) this.el.emit('doubletap');
        lastTap = now;
        pressTimer = setTimeout(() => { if (down) this.el.emit('longpress'); }, this.data.longMs);
      });
      this.el.addEventListener('mouseup', () => {
        down = false;
        clearTimeout(pressTimer);
        this.el.emit('tap');
      });
      this.el.addEventListener('touchstart', e => e.preventDefault(), {passive:false});
    }
  });

  // ---------- 2) Drag on a plane (marker plane) ----------
  // Drag with mouse/touch by intersecting an invisible plane and moving the entity to that point.
  AFRAME.registerComponent('drag-on-plane', {
    schema: { plane: {type: 'selector'}, yOffset: {default: 0.25}, radius: {default: 0.6} },
    init () {
      this.dragging = false;
      this.scene = this.el.sceneEl;
      this.rayEl = document.querySelector('#ray'); // scene cursor ray
      // listen on element
      this.el.addEventListener('mousedown', () => this.dragging = true);
      window.addEventListener('mouseup',   () => this.dragging = false);
      window.addEventListener('touchend',  () => this.dragging = false);
      // move
      this.scene.addEventListener('mousemove', (e)=> this.updateDrag());
      this.scene.addEventListener('touchmove', (e)=> this.updateDrag());
    },
    updateDrag () {
      if (!this.dragging) return;
      if (!this.data.plane) return;
      const raycaster = this.rayEl.getObject3D('raycaster');
      if (!raycaster) return;
      const planeMesh = this.data.plane.getObject3D('mesh');
      if (!planeMesh) return;

      // Build a THREE.Plane from the plane entity (its world transform).
      planeMesh.updateMatrixWorld();
      const normal = new THREE.Vector3(0,1,0).applyQuaternion(planeMesh.getWorldQuaternion(new THREE.Quaternion()));
      const point  = planeMesh.getWorldPosition(new THREE.Vector3());
      const plane  = new THREE.Plane().setFromNormalAndCoplanarPoint(normal, point);

      const ray = raycaster.ray; // world-space ray from cursor
      const hit = new THREE.Vector3();
      if (ray.intersectPlane(plane, hit)) {
        // constrain to radius on XZ around marker center
        const local = this.el.parentEl.object3D.worldToLocal(hit.clone());
        const r = Math.hypot(local.x, local.z);
        const maxR = this.data.radius;
        if (r > maxR){
          const k = maxR / r;
          local.x *= k; local.z *= k;
        }
        this.el.setAttribute('position', `${local.x} ${this.data.yOffset} ${local.z}`);
      }
    }
  });

  // ---------- 3) Pinch to scale ----------
  AFRAME.registerComponent('pinch-scale', {
    schema: {min:{default:0.2}, max:{default:3}},
    init(){
      this.active = false; this.startD = 0; this.startScale = null;
      const onStart = (e) => {
        if (e.touches && e.touches.length === 2){
          this.active = true;
          this.startD = this.dist(e.touches[0], e.touches[1]);
          this.startScale = Object.assign({}, this.el.getAttribute('scale'));
        }
      };
      const onMove = (e) => {
        if (!this.active || !e.touches || e.touches.length < 2) return;
        const d = this.dist(e.touches[0], e.touches[1]);
        const mult = d / this.startD;
        const ns = {
          x: clamp(this.startScale.x * mult, this.data.min, this.data.max),
          y: clamp(this.startScale.y * mult, this.data.min, this.data.max),
          z: clamp(this.startScale.z * mult, this.data.min, this.data.max),
        };
        this.el.setAttribute('scale', ns);
      };
      const onEnd = () => this.active = false;
      window.addEventListener('touchstart', onStart, {passive:false});
      window.addEventListener('touchmove',  onMove,  {passive:false});
      window.addEventListener('touchend',   onEnd);
      window.addEventListener('touchcancel',onEnd);
    },
    dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }
  });

  // ---------- 4) Twist to rotate (two-finger) ----------
  AFRAME.registerComponent('twist-rotate', {
    schema:{degPerRad:{default:57.2958}}, // 180/Ï€
    init(){
      this.active = false; this.startA = 0; this.startRotY = 0;
      const angle = (a,b)=> Math.atan2(b.clientY-a.clientY, b.clientX-a.clientX);
      const onStart = (e)=>{
        if (e.touches && e.touches.length === 2){
          this.active = true;
          this.startA = angle(e.touches[0], e.touches[1]);
          this.startRotY = this.el.getAttribute('rotation').y;
        }
      };
      const onMove = (e)=>{
        if (!this.active || !e.touches || e.touches.length < 2) return;
        const a = angle(e.touches[0], e.touches[1]);
        const delta = (a - this.startA) * this.data.degPerRad;
        const r = this.el.getAttribute('rotation');
        this.el.setAttribute('rotation', {x:r.x, y:this.startRotY + delta, z:r.z});
      };
      const onEnd = ()=> this.active = false;
      window.addEventListener('touchstart', onStart, {passive:false});
      window.addEventListener('touchmove',  onMove,  {passive:false});
      window.addEventListener('touchend',   onEnd);
      window.addEventListener('touchcancel',onEnd);
    }
  });

  // ---------- 5) Spin toggler + random color (hooked to taps) ----------
  AFRAME.registerComponent('spin-toggle', {
    schema:{speed:{default:4000}},
    init(){
      this.spinning = false;
      this.el.addEventListener('toggle-spin', ()=> {
        this.spinning = !this.spinning;
        if (this.spinning) {
          this.el.setAttribute('animation__spin',
            `property: rotation; to: 0 360 0; loop: true; dur: ${this.data.speed}`);
        } else {
          this.el.removeAttribute('animation__spin');
        }
      });
      this.el.addEventListener('random-color', ()=> {
        const colors = ['#4CC3D9','#FFC65D','#7BC8A4','#EF2D5E','#FFFFFF'];
        const c = colors[Math.floor(Math.random()*colors.length)];
        this.el.setAttribute('material','color',c);
      });
    }
  });
  </script>
</head>
<body>
  <!-- HUD -->
  <div class="hud" id="hud">
    <button id="btn-rot-l">âŸ²</button>
    <button id="btn-rot-r">âŸ³</button>
    <button id="btn-scale--">âˆ’</button>
    <button id="btn-scale-+">ï¼‹</button>
    <button id="btn-color">ðŸŽ¨</button>
  </div>
  <div class="story" id="story">Scan the sky marker to awaken the scene.</div>

  <a-scene
    embedded
    renderer="colorManagement: true; physicallyCorrectLights: true"
    xr-mode-ui="enabled: false"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false">

    <!-- Cursor ray for mouse/touch (A-Frame builds a raycaster object3D for us) -->
    <a-entity id="ray" cursor="rayOrigin: mouse" raycaster="objects: .raytarget"></a-entity>

    <!-- Lights -->
    <a-entity id="ambLight" light="type: ambient; intensity: 0.9; color: #a5c2ff"></a-entity>
    <a-entity id="dirLight" light="type: directional; intensity: 0.65; color: #cdd9ff" position="0 1 1"></a-entity>

    <a-nft
      id="marker"
      type="nft"
      emitevents="true"
      url="360_F_307438274_Q7IwbWhh6JssHt8ma0PjrxHlalOPHNgY"
      smooth="true"
      smoothCount="10"
      smoothTolerance="0.01"
      smoothThreshold="5">

      <!-- Invisible drag plane anchored to marker -->
      <a-plane id="dragplane" class="raytarget"
               position="0 0 0" rotation="-90 0 0" width="2" height="2"
               material="color: #000; opacity: 0; transparent: true"></a-plane>

      <!-- Interactive 3D model -->
      <a-entity id="cube" class="raytarget"
                position="0 0.1 0"
                scale="1.2 1.2 1.2"
                gltf-model="starry_night_sky_hdri_background_photosphere/scene.gltf"
                tap-gestures spin-toggle
                drag-on-plane="plane: #dragplane; yOffset: 0.1; radius: 0.6"
                pinch-scale twist-rotate>
      </a-entity>

      <a-entity id="story3d-a"
                text="value: ; align: center; width: 6; color: #fffbe6; opacity: 0"
                position="0 3 0"
                scale="1 1 1"
                material="shader: flat; transparent: true; depthTest: false; depthWrite: false"
                look-at-camera always-on-top
                visible="false"
                animation__fadein="property: text.opacity; from: 0; to: 1; dur: 400; easing: easeOutQuad"
                animation__fadeout="property: text.opacity; from: 1; to: 0; dur: 400; easing: easeOutQuad"
      ></a-entity>

      <!-- Marker center dot (optional) -->
      <a-cylinder radius="0.01" height="0.001" color="#888"></a-cylinder>
    </a-nft>

    <!-- Second marker, gated to appear only after the first is seen -->
    <a-nft
      id="marker-b"
      type="nft"
      emitevents="true"
      url="squirrel-clipart-cheek-stuffer-squirrel-vector-illustration-black-white_1027351-12994"
      visible="false"
      smooth="true"
      smoothCount="10"
      smoothTolerance="0.01"
      smoothThreshold="5">

      <a-plane id="dragplane-b" class="raytarget"
               position="0 0 0" rotation="-90 0 0" width="2" height="2"
               material="color: #000; opacity: 0; transparent: true"></a-plane>

      <a-entity id="cube-b" class="raytarget"
                position="0 0.15 0"
                scale="1.2 1.2 1.2"
                gltf-model="free_-_skybox_anime_sky/scene.gltf"
                tap-gestures spin-toggle
                drag-on-plane="plane: #dragplane-b; yOffset: 0.15; radius: 0.6"
                pinch-scale twist-rotate>
      </a-entity>

      <a-entity id="story3d-b"
                text="value: ; align: center; width: 6; color: #fffbe6; opacity: 0"
                position="0 3 0"
                scale="1 1 1"
                material="shader: flat; transparent: true; depthTest: false; depthWrite: false"
                look-at-camera always-on-top
                visible="false"
                animation__fadein="property: text.opacity; from: 0; to: 1; dur: 400; easing: easeOutQuad"
                animation__fadeout="property: text.opacity; from: 1; to: 0; dur: 400; easing: easeOutQuad"
      ></a-entity>

      <a-cylinder radius="0.01" height="0.001" color="#444"></a-cylinder>
    </a-nft>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    const hud  = document.getElementById('hud');
    const cube = document.getElementById('cube');
    const cubeB = document.getElementById('cube-b');
    const story = document.getElementById('story');
    const story3dA = document.getElementById('story3d-a');
    const story3dB = document.getElementById('story3d-b');
    const ambLight = document.getElementById('ambLight');
    const dirLight = document.getElementById('dirLight');

    // Buttons
    document.getElementById('btn-rot-l').addEventListener('click', () => nudgeRot(-15));
    document.getElementById('btn-rot-r').addEventListener('click', () => nudgeRot( 15));
    function nudgeRot(delta){
      const r = cube.getAttribute('rotation');
      cube.setAttribute('rotation', {x:r.x, y:r.y + delta, z:r.z});
    }

    document.getElementById('btn-scale--').addEventListener('click', () => nudgeScale(0.9));
    document.getElementById('btn-scale-+').addEventListener('click', () => nudgeScale(1.1));
    function nudgeScale(mult){
      const s = cube.getAttribute('scale');
      cube.setAttribute('scale', {
        x: clamp(s.x * mult, 0.2, 3),
        y: clamp(s.y * mult, 0.2, 3),
        z: clamp(s.z * mult, 0.2, 3)
      });
    }

    document.getElementById('btn-color').addEventListener('click', () => cube.emit('random-color'));

    const showStory = (msg, ms = 5000) => {
      clearTimeout(showStory._t);
      story.textContent = msg;
      story.classList.add('visible');
      showStory._t = setTimeout(() => hideStory(), ms);
    };

    const hideStory = () => {
      clearTimeout(showStory._t);
      story.classList.remove('visible');
    };

    // Initial prompt before any marker is found
    showStory('Scan the sky marker to awaken the scene.', 5000);

    // Gesture hooks
    cube.addEventListener('tap',       () => cube.emit('toggle-spin'));        // single tap: spin on/off
    cube.addEventListener('doubletap', () => cube.emit('random-color'));       // double tap: recolor
    cube.addEventListener('longpress', () => hud.classList.toggle('hidden'));  // long press: show/hide HUD

    // Sequential marker gating: B stays hidden until A is seen once
    const markerA = document.getElementById('marker');
    const markerB = document.getElementById('marker-b');
    let unlockedB = false;
    let poppedA = false;
    const lockMarkerB = () => {
      markerB.object3D.visible = false;
      markerB.setAttribute('visible', false);
      if (cubeB && cubeB.object3D) {
        cubeB.object3D.visible = false;
      }
    };
    lockMarkerB();
    markerB.addEventListener('componentchanged', (e) => {
      if (e.detail.name === 'visible' && !unlockedB) {
        lockMarkerB();
      }
    });

    let markerAVisible = false;
    markerA.addEventListener('markerFound', () => {
      markerAVisible = true;
      hideStory();   // <= instantly hide any current story text

      if (!poppedA) {
        poppedA = true;
        // Play a one-time scale-up when marker A is first seen
        cube.removeAttribute('animation__pop');
        cube.setAttribute('scale', {x:0.01, y:0.01, z:0.01});
        cube.setAttribute('animation__pop',
                'property: scale; to: 3 3 3; dur: 800; easing: easeOutElastic;');
      }
      if (!unlockedB) {
        unlockedB = true;
        markerB.object3D.visible = true;
        markerB.setAttribute('visible', true);
        if (cubeB && cubeB.object3D) cubeB.object3D.visible = true;
      }
    });

    markerA.addEventListener('markerLost', () => {
      markerAVisible = false;
      showStory('The starry sky stirsâ€”find the guardian.', 5000);
    });

    let markerBVisible = false;
    markerB.addEventListener('markerFound', () => {
      markerBVisible = true;
      hideStory();
    });

    markerB.addEventListener('markerLost', () => {
      markerBVisible = false;
      showStory('Guardian revealed. The anime sky awaits.', 5000);
      // showStory('The starry sky stirsâ€”find the guardian.', 5000);

    });

    // Reliable marker lost detection for NFT markers
    // setInterval(() => {
    //   // --- Marker A ---
    //   const isAVisible = markerA.object3D.visible;
    //   if (isAVisible && !markerAVisible) {
    //     markerAVisible = true;
    //     hideStory();
    //   }
    //   if (!isAVisible && markerAVisible) {
    //     markerAVisible = false;
    //     showStory('The starry sky stirsâ€”find the guardian.', 5000);
    //   }
    //
    //   // --- Marker B ---
    //   const isBVisible = markerB.object3D.visible;
    //   if (isBVisible && !markerBVisible) {
    //     markerBVisible = true;
    //     hideStory();
    //   }
    //   if (!isBVisible && markerBVisible) {
    //     markerBVisible = false;
    //     // showStory('Guardian revealed. The anime sky awaits.', 5000);
    //     showStory('Clean sky unlocked â€” enjoy the guardian realm.', 5000);
    //   }
    // }, 150); // runs every 150ms

  </script>
</body>
</html>